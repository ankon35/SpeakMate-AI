<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiveKit Agent Controller</title>
    <!-- LiveKit Client SDK -->
    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --primary: #3b82f6;
            --danger: #ef4444;
            --success: #22c55e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 90vh;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        h2, h3 { margin: 0; font-weight: 600; }
        h2 { font-size: 1.25rem; color: var(--primary); border-bottom: 1px solid #334155; padding-bottom: 10px; }
        h3 { font-size: 1rem; color: var(--text-muted); }

        .controls { display: flex; gap: 10px; flex-wrap: wrap; }
        
        button {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--primary); color: white; }
        .btn-danger { background-color: var(--danger); color: white; }
        .btn-success { background-color: var(--success); color: white; }

        input, select {
            background: #334155;
            border: 1px solid #475569;
            color: white;
            padding: 8px;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
        }

        .log-box {
            background: #000;
            color: #22c55e;
            font-family: monospace;
            padding: 10px;
            border-radius: 6px;
            height: 150px;
            overflow-y: auto;
            font-size: 0.85rem;
        }

        .status-dot {
            height: 10px;
            width: 10px;
            background-color: #64748b;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .status-dot.active { background-color: var(--success); box-shadow: 0 0 8px var(--success); }

        .history-list {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #334155;
            border-radius: 6px;
        }
        .history-item {
            padding: 10px;
            border-bottom: 1px solid #334155;
            cursor: pointer;
        }
        .history-item:hover { background: #334155; }
        
        .chat-view {
            background: #0f172a;
            padding: 10px;
            border-radius: 6px;
            height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .msg { padding: 8px 12px; border-radius: 8px; max-width: 80%; font-size: 0.9rem; }
        .msg.user { align-self: flex-end; background: var(--primary); }
        .msg.agent { align-self: flex-start; background: #475569; }

        /* Visualizer */
        #visualizer { width: 100%; height: 50px; background: #000; margin-top: 10px; border-radius: 4px; }
        
        .config-info {
            font-size: 0.75rem;
            color: var(--text-muted);
            background: #0f172a;
            padding: 8px;
            border-radius: 4px;
            word-break: break-all;
        }
    </style>
</head>
<body>

<div class="container">
    <!-- LEFT PANEL: CONNECTION & CONTROLS -->
    <div class="card">
        <h2>ðŸš€ Operations Center</h2>

        <!-- Backend Controls -->
        <div>
            <h3>1. Backend Agent Process <span id="backendStatus" class="status-dot"></span></h3>
            <p style="font-size: 0.8rem; color: #94a3b8; margin: 5px 0;">Controls the python process defined in api.py</p>
            <div class="controls">
                <button onclick="startBackend()" class="btn-success">Start Agent</button>
                <button onclick="stopBackend()" class="btn-danger">Stop Agent</button>
            </div>
        </div>

        <hr style="border-color: #334155; width: 100%;">

        <!-- Client Connection -->
        <div>
            <h3>2. Browser Connection (The User) <span id="clientStatus" class="status-dot"></span></h3>
            <p style="font-size: 0.8rem; color: #94a3b8; margin: 5px 0;">Connect your microphone to the room.</p>
            
            <div class="config-info" style="margin-bottom: 10px;">
                <strong>Server:</strong> <span id="serverUrl">Not loaded</span><br>
                <strong>Token:</strong> <span id="tokenStatus">Not generated</span>
            </div>

            <div class="controls">
                <button id="connectBtn" onclick="connectToRoom()" class="btn-primary">Connect Audio</button>
                <button id="disconnectBtn" onclick="disconnectRoom()" class="btn-danger" disabled>Disconnect</button>
            </div>
        </div>

        <!-- Audio Visualizer -->
        <div style="margin-top: auto;">
            <h3>Audio Output</h3>
            <canvas id="visualizer"></canvas>
            <div id="audioContainer"></div>
        </div>
    </div>

    <!-- RIGHT PANEL: LOGS & HISTORY -->
    <div class="card">
        <h2>ðŸ“œ Logs & History</h2>

        <!-- Live Logs -->
        <div class="log-box" id="appLog">
            <div>> System initialized...</div>
        </div>

        <!-- Conversation History -->
        <div style="display:flex; justify-content: space-between; align-items: center; margin-top: 10px;">
            <h3>Saved Conversations</h3>
            <button onclick="loadConversations()" style="font-size: 0.7rem;">Refresh</button>
        </div>
        
        <div class="history-list" id="fileList">
            <!-- File list populates here -->
        </div>

        <!-- Selected Chat View -->
        <h3>Transcript Viewer</h3>
        <div class="chat-view" id="chatDisplay">
            <div style="text-align: center; color: #64748b; margin-top: 20px;">Select a conversation to view</div>
        </div>
    </div>
</div>

<script>
    const API_URL = "http://localhost:8080";
    let room = null;
    let liveKitConfig = null;

    function log(msg, type='info') {
        const logBox = document.getElementById('appLog');
        const entry = document.createElement('div');
        const time = new Date().toLocaleTimeString();
        entry.textContent = `[${time}] ${msg}`;
        if(type === 'error') entry.style.color = '#ef4444';
        logBox.appendChild(entry);
        logBox.scrollTop = logBox.scrollHeight;
    }

    async function loadConfig() {
        try {
            log("Loading LiveKit configuration...");
            const res = await fetch(`${API_URL}/config`);
            const data = await res.json();
            
            if (data.error) {
                log(`Config error: ${data.error}`, 'error');
                document.getElementById('serverUrl').textContent = 'Error loading';
                document.getElementById('tokenStatus').textContent = 'Error';
                return false;
            }
            
            liveKitConfig = data;
            document.getElementById('serverUrl').textContent = data.url;
            document.getElementById('tokenStatus').textContent = 'Generated âœ“';
            log("Configuration loaded successfully!");
            return true;
        } catch (e) {
            log(`Failed to load config: ${e}`, 'error');
            return false;
        }
    }

    async function startBackend() {
        try {
            log("Requesting backend start...");
            const res = await fetch(`${API_URL}/start_server`, { method: 'POST' });
            const data = await res.json();
            log(`Backend: ${data.status} (PID: ${data.pid || 'N/A'})`);
            
            if (data.status === 'starting' || data.status === 'agent_already_running') {
                document.getElementById('backendStatus').classList.add('active');
                
                // Auto-load config after starting backend
                setTimeout(async () => {
                    await loadConfig();
                }, 1000);
            }
        } catch (e) {
            log(`Error starting backend: ${e}`, 'error');
        }
    }

    async function stopBackend() {
        try {
            log("Requesting backend stop...");
            const res = await fetch(`${API_URL}/stop_server`, { method: 'POST' });
            const data = await res.json();
            log(`Backend: ${data.status}`);
            document.getElementById('backendStatus').classList.remove('active');
        } catch (e) {
            log(`Error stopping backend: ${e}`, 'error');
        }
    }

    async function connectToRoom() {
        // Load config if not already loaded
        if (!liveKitConfig) {
            const success = await loadConfig();
            if (!success) {
                alert("Failed to load LiveKit configuration. Make sure the backend is running and .env file is configured.");
                return;
            }
        }

        const url = liveKitConfig.url;
        const token = liveKitConfig.token;
        let selectedDeviceId = null;

        // 1. Explicitly check Mic and GET THE DEVICE ID
        log("Checking microphone...");
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            // Get the ID of the mic that just worked
            const track = stream.getAudioTracks()[0];
            selectedDeviceId = track.getSettings().deviceId;
            log(`Microphone authorized (ID: ${selectedDeviceId.slice(0,5)}...)`);
            
            // Clean up the test stream so LiveKit can take over
            track.stop();
        } catch (err) {
            log("Microphone access denied!", 'error');
            alert("Error: You must allow microphone access.");
            return;
        }

        // 2. Connect to LiveKit
        try {
            log("Connecting to LiveKit Room...");
            
            room = new LivekitClient.Room({
                adaptiveStream: true,
                dynacast: true,
            });

            room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
                log(`Track subscribed: ${track.kind}`);
                if (track.kind === 'audio') {
                    const element = track.attach();
                    document.getElementById('audioContainer').appendChild(element);
                    setupVisualizer(element.srcObject);
                }
            });

            room.on(LivekitClient.RoomEvent.Disconnected, () => {
                log("Disconnected from room.");
                resetUI();
            });

            await room.connect(url, token);
            log(`Connected to room: ${room.name}`);

            // 3. Publish Microphone using the SPECIFIC ID we found earlier
            log("Publishing microphone...");
            
            // We use setMicrophoneEnabled with the explicit deviceId
            await room.localParticipant.setMicrophoneEnabled(true, {
                deviceId: selectedDeviceId
            });
            
            log("Microphone published successfully!");

            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
            document.getElementById('clientStatus').classList.add('active');

        } catch (e) {
            log(`Connection failed: ${e}`, 'error');
        }
    }

    async function disconnectRoom() {
        if (room) {
            await room.disconnect();
            resetUI();
        }
    }

    function resetUI() {
        document.getElementById('connectBtn').disabled = false;
        document.getElementById('disconnectBtn').disabled = true;
        document.getElementById('clientStatus').classList.remove('active');
        document.getElementById('audioContainer').innerHTML = '';
    }

    async function loadConversations() {
        try {
            const res = await fetch(`${API_URL}/conversations`);
            const files = await res.json();
            const list = document.getElementById('fileList');
            list.innerHTML = '';
            
            files.forEach(file => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.textContent = file;
                div.onclick = () => loadTranscript(file);
                list.appendChild(div);
            });
            log("Conversation list updated.");
        } catch (e) {
            log(`Failed to load history: ${e}`, 'error');
        }
    }

    async function loadTranscript(filename) {
        try {
            const res = await fetch(`${API_URL}/conversation/${filename}`);
            const messages = await res.json();
            const view = document.getElementById('chatDisplay');
            view.innerHTML = '';

            messages.forEach(msg => {
                const bubble = document.createElement('div');
                bubble.className = `msg ${msg.role === 'agent' ? 'agent' : 'user'}`;
                bubble.innerHTML = `<strong>${msg.role}:</strong> ${msg.content}`;
                view.appendChild(bubble);
            });
        } catch (e) {
            log(`Error loading transcript: ${e}`, 'error');
        }
    }

    function setupVisualizer(stream) {
        const canvas = document.getElementById("visualizer");
        const ctx = canvas.getContext("2d");
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        
        src.connect(analyser);
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let barHeight;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                barHeight = dataArray[i] / 2;
                ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }
        draw();
    }

    // Load conversations and config on page load
    loadConversations();
    loadConfig();
</script>

</body>
</html>